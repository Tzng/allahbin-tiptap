### addKeyboardShortcuts

在 `@tiptap/core` 中的 `addKeyboardShortcuts()` 方法用于为编辑器的扩展添加键盘快捷方式。这个方法通常在创建一个新的节点或扩展时使用，使得用户可以通过键盘快捷键快速执行某些命令。

在你提供的代码示例中，`addKeyboardShortcuts()` 方法通过使用 `reduce` 函数在 `this.options.levels` 上迭代，为每个级别的标题添加一个键盘快捷键。`this.options.levels` 应该是一个包含标题级别（如1, 2, 3等）的数组。

代码的工作流程如下：

1. 使用 `reduce` 函数遍历 `this.options.levels` 数组，为每个标题级别构建一个键盘快捷键。
2. 对于每个级别 `level`，添加一个快捷键映射到 `Mod-Alt-${level}`。这里的 `Mod` 通常指的是平台无关的修饰键（在 Windows/Linux 上通常是 `Ctrl`，在 macOS 上是 `Cmd`），`Alt` 是另一个修饰键，`${level}` 是动态插入的标题级别。
3. 当这个快捷键被触发时，执行 `this.editor.commands.toggleHeading({ level })`，这个命令会根据当前的文档状态切换指定级别的标题或转换为普通段落。

例如，如果 `this.options.levels` 包含 `[1, 2, 3]`，则此方法将为 `Mod-Alt-1`, `Mod-Alt-2`, 和 `Mod-Alt-3` 分别添加快捷键。按下这些快捷键时，将会触发对应级别的标题切换。

这种方式使得用户可以非常便捷地通过键盘快捷键来控制文档中的标题级别，提高了编辑效率。

### addInputRules

在 `@tiptap/core` 中的 `addInputRules()` 方法用于为编辑器的扩展添加输入规则，这些规则可以在用户输入文本时自动触发某些转换或格式应用，从而提升用户的编辑体验。

在你提供的代码示例中，`addInputRules()` 方法使用 `map` 函数遍历 `this.options.levels` 数组，为每个标题级别设置一个输入规则。这些输入规则使用 `textblockTypeInputRule` 函数创建，这是一个用于匹配文本块类型（如段落、标题等）的输入规则帮助函数。

代码的工作流程如下：

1. **遍历标题级别**：使用 `map` 函数对每个 `level`（标题级别）进行遍历。
2. **正则表达式匹配**：对于每个级别，创建一个正则表达式 `new RegExp(`^(!{1,${level}})\\s$`)`。这个正则表达式试图匹配行首开始的一到多个感叹号（数量取决于标题级别 `level`），后跟一个空格。例如，对于级别 1，正则表达式将匹配 `! `；对于级别 2，将匹配 `!! `，依此类推。
3. **设置节点类型和属性**：`textblockTypeInputRule` 接受一个配置对象，其中 `type` 设置为 `this.type`（当前扩展或节点的类型），`getAttributes` 是一个返回属性对象的函数，其中包含了标题的级别信息。
4. **应用规则**：当输入匹配到上述正则表达式时，`textblockTypeInputRule` 规则会自动将当前文本块转换为指定的 `type`（比如标题节点），并应用 `getAttributes` 返回的属性（如 `level`），从而实现自动格式化。

这种输入规则非常有用，因为它允许用户通过简单的键入特定模式来快速设置文本的格式，例如，通过键入 `! ` 来快速设置文本为一级标题。这样的功能提高了编辑效率并增强了用户体验。

### renderHTML

在 `@tiptap/core` 中的 `renderHTML()` 方法被用来定义如何将一个节点渲染为 HTML。这个方法是节点或扩展的一部分，负责将编辑器中的文档模型节点转换成对应的 HTML 输出。这对于服务器端渲染或将编辑器内容转换为可显示的网页格式尤为重要。

在你提供的代码示例中，`renderHTML()` 方法用于渲染一个具有不同级别的标题节点。方法接收一个对象，包含 `node` 和 `HTMLAttributes`。`node` 是当前正在渲染的节点，`HTMLAttributes` 是应用于该节点的额外 HTML 属性。

代码的工作流程如下：

1. **检查级别有效性**：首先检查 `node.attrs.level`（节点的标题级别属性）是否包含在 `this.options.levels` 中。如果包含，`hasLevel` 为 `true`；否则为 `false`。
2. **确定标题级别**：如果 `hasLevel` 为 `true`，则使用 `node.attrs.level` 作为标题级别；如果为 `false`，则默认使用 `this.options.levels` 数组中的第一个元素作为级别。这是一种容错措施，确保总是有有效的标题级别。
3. **合并属性**：使用 `mergeAttributes` 函数合并 `this.options.HTMLAttributes`（可能在扩展定义时指定的默认 HTML 属性）与传入的 `HTMLAttributes`。这允许自定义和扩展默认属性。
4. **返回 HTML 结构**：最终返回一个数组，其中包含：
    - 标题标签名（如 `h1`, `h2` 等），通过模板字符串 `h${level}` 动态生成。
    - 合并后的 HTML 属性。
    - 一个数字 `0`，在 TiPTap 中这通常表示该节点是一个空的容器，可以包含子节点。

这个方法的实现确保了标题节点可以灵活地渲染为不同级别的 HTML 标签，并且能够接受外部传入的 HTML 属性，使得渲染过程既标准化又可定制。这对于创建符合特定设计要求的富文本编辑器至关重要。


### parseHTML

在 `@tiptap/core` 或类似的富文本编辑框架中，`parseHTML()` 方法用于定义如何从 HTML 元素解析出编辑器的节点。这个方法是节点或扩展的一部分，负责将从外部来源（如从数据库加载的 HTML 文本）导入的 HTML 转换成编辑器内部使用的文档模型。

在你提供的代码示例中，`parseHTML()` 方法用于解析不同级别的标题元素（如 `<h1>`, `<h2>`, `<h3>` 等）。方法通过映射 `this.options.levels` 数组来生成一个解析规则数组，每个规则对应一个标题级别。

代码的工作流程如下：

1. **映射标题级别**：使用 `map` 函数遍历 `this.options.levels` 数组，为每个级别 `level` 创建一个解析规则。
2. **创建解析规则**：对于每个级别，生成一个对象，其中包含：
    - `tag`：一个字符串，表示 HTML 中对应的标签名（如 `h1`, `h2` 等），通过模板字符串 `h${level}` 动态生成。
    - `attrs`：一个对象，用于指定解析后节点的属性。在这里，它包含一个 `level` 属性，其值设置为当前的 `level`。这样，解析后的节点将保持与原 HTML 标签相对应的级别属性。

这种方法的实现确保了编辑器能够正确识别和导入各种级别的标题，将其转换为内部文档模型中的相应节点。例如，当编辑器遇到一个 `<h2>` 标签时，它会创建一个标题节点，其 `level` 属性设置为 `2`。

这对于确保编辑器内容与外部源（如数据库或其他网页）之间的一致性和兼容性非常重要，特别是在内容需要在不同平台或格式之间迁移和转换时。

